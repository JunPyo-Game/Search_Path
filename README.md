# 구현된 경로탐색 알고리즘 정리

이 프로젝트에는 다음과 같은 경로탐색(Pathfinding) 알고리즘이 구현되어 있습니다.

---

## 1. Depth-First Search (DFS)
- **파일:** `Assets/02_Scripts/DepthFirstSearch.cs`
- **특징:**
  - 스택(Stack) 기반의 깊이 우선 탐색
  - 한 방향으로 끝까지 탐색 후, 막히면 되돌아가서 다른 경로 탐색
  - 최단 경로를 보장하지 않음
  - 구현이 간단하고, 메모리 사용량이 적음

- **로직 단계:**
  1. 시작 위치를 visited 집합에 추가하고, 스택에 push
  2. 스택에서 노드를 pop하여 현재 위치로 설정
  3. 현재 위치가 목적지면 경로 재구성(SetPath) 후 종료
  4. 8방향(상하좌우+대각선)으로 이동 가능한 모든 위치에 대해:
     - 방문하지 않았고, 이동 가능하면 visited에 추가 후 스택에 push
  5. 스택이 빌 때까지 2~4 반복

---

## 2. Breadth-First Search (BFS)
- **파일:** `Assets/02_Scripts/BreadthFirstSearch.cs`
- **특징:**
  - 큐(Queue) 기반의 너비 우선 탐색
  - 가까운 노드부터 차례로 탐색
  - 장애물이 없을 때, 모든 간선의 비용이 같다면 최단 경로 보장
  - 구현이 간단하며, 최단 경로가 필요한 경우 적합

- **로직 단계:**
  1. 시작 위치를 visited 집합에 추가하고, 큐에 enqueue
  2. 큐에서 노드를 dequeue하여 현재 위치로 설정
  3. 현재 위치가 목적지면 경로 재구성(SetPath) 후 종료
  4. 8방향(상하좌우+대각선)으로 이동 가능한 모든 위치에 대해:
     - 방문하지 않았고, 이동 가능하면 visited에 추가 후 큐에 enqueue
  5. 큐가 빌 때까지 2~4 반복

---

## 3. A* (A-Star) Search
- **파일:** `Assets/02_Scripts/AStar.cs`
- **특징:**
  - 우선순위 큐(PriorityQueue) 기반의 탐색
  - g(시작점~현재까지 실제 누적 비용) + h(목적지까지의 휴리스틱) 합이 최소인 노드부터 탐색
  - h(휴리스틱)는 유클리드 거리(Vector3.Distance) 사용
  - 장애물, 대각선 이동, 가중치 등 다양한 상황에서 최적의 경로(최단 경로) 보장
  - 경로 품질과 성능이 모두 우수함

- **로직 단계:**
  1. 시작 위치에 대해 g=0, h=목적지까지 거리로 초기화, nodeMap에 등록 후 우선순위 큐에 enqueue
  2. 우선순위 큐에서 g+h가 최소인 노드를 dequeue하여 현재 위치로 설정
  3. 현재 위치가 목적지면 경로 재구성(SetPath) 후 종료
  4. 8방향(상하좌우+대각선)으로 이동 가능한 모든 위치에 대해:
     - 이동 가능하면, stepCost(이동 비용) 계산
     - nodeMap에 없으면 새 노드 생성(g, h, prevNode 설정) 후 등록 및 큐에 enqueue
     - 이미 등록된 위치라면, 더 짧은 경로(g값이 더 작음)일 때만 g, prevNode 갱신 후 큐에 enqueue
  5. 큐가 빌 때까지 2~4 반복

---

## 4. A* 변형 및 고급 구현

### 1) 우선순위 큐 + ClosedSet 기반 중복 노드 방지
- **파일:** `Assets/02_Scripts/AStar_PriorityQueueWithClosedSet.cs`
- **설명:**
  - 우선순위 큐(PriorityQueue)로 g+h가 최소인 노드를 우선 탐색
  - ClosedSet(HashSet)으로 이미 최적 경로가 확정된 위치는 중복 방문 방지
  - Dictionary<Vector3, Node>로 각 위치별 노드 1개만 관리
  - 중복 노드 삽입/불필요한 연산 최소화, 경로 품질과 성능 모두 우수

### 2) 인덱스 기반 우선순위 큐(IndexedPriorityQueue) 사용
- **파일:** `Assets/02_Scripts/AStar_IndexedPriorityQueue.cs`
- **설명:**
  - 큐 내부에서 노드의 위치(인덱스)를 빠르게 추적/갱신할 수 있는 자료구조 사용
  - 기존 PriorityQueue 대비, 노드 우선순위 갱신(DecreaseKey 등)이 매우 빠름
  - 대규모 맵, 빈번한 경로 갱신 상황에서 성능상 이점
  - ClosedSet 없이도 중복 노드 관리가 효율적

### 3) 다양한 휴리스틱(Heuristic) 계산법
- **A*의 경로 품질과 성능은 휴리스틱 함수에 크게 영향받음**
- 대표적인 휴리스틱 공식:

  - **유클리드 거리(Euclidean Distance)**
    - $h(n) = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}$
    - 대각선 이동, 3D 공간에 적합
  - **맨해튼 거리(Manhattan Distance)**
    - $h(n) = |x_2-x_1| + |y_2-y_1| + |z_2-z_1|$
    - 격자 기반, 상하좌우 이동만 허용 시 최적
  - **체비셰프/대각선 거리(Chebyshev/Diagonal Distance)**
    - $h(n) = \max(|x_2-x_1|, |y_2-y_1|, |z_2-z_1|)$
    - 대각선 이동이 1칸씩 허용될 때
  - **제곱 거리(Squared Euclidean)**
    - $h(n) = (x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2$
    - 연산량 최소화, 최적 경로 보장 X

- **휴리스틱 선택 팁:**
  - 격자/상하좌우: 맨해튼
  - 대각선 허용: 유클리드, 대각선 거리
  - 3D 공간: 유클리드, 맨해튼
  - 성능 중시: 제곱 거리(비최적 경로 허용)
---

## 우선순위 큐(Priority Queue)와 인덱스 기반 우선순위 큐(IndexedPriorityQueue) 비교

### 1) 우선순위 큐(Priority Queue)
- **개념:**
  - 각 노드에 우선순위(보통 g+h)를 부여하고, 우선순위가 가장 낮은(최소) 노드를 빠르게 꺼낼 수 있는 자료구조
  - 일반적으로 힙(Heap) 구조로 구현
- **장점:**
  - 삽입, 삭제, 최소값 추출이 빠름($O(\log n)$)
  - 구현이 간단하고, 다양한 언어/라이브러리에서 지원
- **단점:**
  - 큐 내부에서 특정 노드의 우선순위(키) 변경(DecreaseKey)이 비효율적(일반적으로 지원하지 않음)
  - 이미 큐에 있는 노드의 우선순위가 바뀌면, 중복 삽입 후 나중에 무시하는 방식이 필요

### 2) 인덱스 기반 우선순위 큐(IndexedPriorityQueue)
- **개념:**
  - 각 노드의 위치(인덱스)를 별도로 추적하여, 노드의 우선순위(키) 변경(DecreaseKey) 연산을 빠르게 지원하는 큐
  - 힙 + 인덱스 맵(Dictionary/배열) 조합으로 구현
- **장점:**
  - 노드의 우선순위 갱신(DecreaseKey)이 매우 빠름($O(\log n)$)
  - 중복 노드 삽입 없이, 항상 최신 우선순위로 관리 가능
  - 대규모 맵, 빈번한 경로 갱신 상황에서 성능상 이점
- **단점:**
  - 구현이 복잡(추가 자료구조 필요)
  - 메모리 사용량이 약간 증가

### 3) 실제 적용 팁
- 작은 맵/간단한 상황: 일반 우선순위 큐로도 충분
- 대규모 맵/실시간 경로 갱신: 인덱스 기반 우선순위 큐가 더 효율적
- Unity/C#에서는 커스텀 구현이 필요할 수 있음

---

## 공통 구조
- **PathSearch.cs**: 모든 알고리즘의 추상 기반 클래스
  - 경로 노드(PathNode), 방향 배열, 이벤트/콜백, 경로 재구성(SetPath) 등 공통 기능 제공

---

## 참고
- 각 알고리즘은 Unity 환경에서 동작하며, 장애물/벽/대각선 이동 등 다양한 상황을 지원하도록 구현되어 있습니다.
- A*는 실제 게임/시뮬레이션에서 가장 널리 쓰이는 경로탐색 알고리즘입니다.
